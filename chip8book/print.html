<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing a Chip-8 Emulator in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="0-initial_framework.html"><strong aria-hidden="true">1.</strong> Initial Framework</a></li><li class="chapter-item expanded "><a href="1-first_test.html"><strong aria-hidden="true">2.</strong> First Test</a></li><li class="chapter-item expanded "><a href="2-passing_first_test.html"><strong aria-hidden="true">3.</strong> Passing the First Test</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2-1-basic_instructions.html"><strong aria-hidden="true">3.1.</strong> Basic Instructions for the First Test</a></li><li class="chapter-item expanded "><a href="2-2-basic_graphical_instructions.html"><strong aria-hidden="true">3.2.</strong> Graphical Instructions for the First Test</a></li></ol></li><li class="chapter-item expanded "><a href="checkpoint_1.html"><strong aria-hidden="true">4.</strong> Checkpoint 1</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">5.</strong> Todo</a></li><li class="chapter-item expanded "><a href="refernces.html"><strong aria-hidden="true">6.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Writing a Chip-8 Emulator in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/CHIP-8">Chip-8</a> system  is whats known as a fantasy console, which roughly means that it wasn’t made to be run directly on real hardware. Instead, even at its first implementation around 50 years ago it was emulated.</p>
<p>In my experience it is commonly used as the “Hello world” of console emulation. This is due to features such as its simplicity, relatively low performance requirements, and just being fairly well known. Looking at a Gameboy, there are multiple ways of handling values inside instructions, a complicated sprite system, a system of palettes for handling color, and many more features that make emulating a Gameboy fairly complex. Compare that to the Chip-8 and you will find a simpler system for handling values, a much simpler sprite system, and a two color display that allows the screen to be simulated with an fairly small array of booleans.</p>
<p>Because it was originally being emulated on such old hardware, even python is more than fast enough to emulate Chip-8, but since Rust is so strict with things like data types it will help prevent annoying bugs. I’m choosing Rust over C++ or similar simply because I am better at it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-framework"><a class="header" href="#initial-framework">Initial Framework</a></h1>
<p>First, we need to create the project. The simplest way would be to run <code>cargo new chip8 --lib</code>. You can delete everything in the lib.rs file. After that we can really start.</p>
<p>One way to start off is to write a basic, but initially empty, framework for the emulator, then we can write a simple test that tries to run a program for a certain number of steps and without checking any values, at least for now.</p>
<pre><code class="language-rust">// lib.rs

#[cfg(test)]
mod tests;

pub struct Chip8{

}

impl Chip8{
    pub fn new(program: &amp;[u8])-&gt;Self{
        todo!()
    }
    pub fn step(&amp;mut self){
        todo!()
    }
}</code></pre>
<p>This will be our starting framework. Below is an explanation for each part.</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests;</code></pre>
<p>The first line says to skip the second line unless the tests are being run. This allows us to have a file with tests without the tests interfering with the emulator when it's being run. The second line, if it isn't skipped, will connect to a file called tests.rs that will eventually have our tests.</p>
<pre><code class="language-rust">pub struct Chip8{

}</code></pre>
<p>This will be the object that holds all the data being used by the emulator. For now, it is intentionally left empty.</p>
<pre><code class="language-rust">impl Chip8{
    pub fn new(program: &amp;[u8])-&gt;Self{
        todo!()
    }
    pub fn step(&amp;mut self){
        todo!()
    }
}</code></pre>
<p>These are the two starting methods for the emulator. The new function will initialize the emulator and get it ready to run the program. The step function will execute one instruction from the program.</p>
<p>Currently, trying to run the tests will mean it fails to compile, so next we will create the tests.rs file. You can try using <code>cargo test</code> but unless you create the tests.rs file or remove the <code>mod tests;</code> line it shouldn't be able to work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-test"><a class="header" href="#first-test">First Test</a></h1>
<p>Next we need to write the test.rs file. We want a test program for our first test to run. A common starting point for Chip-8 emulators is a rom that just displays an IBM logo. I have seen different versions of this rom online, so it will be easiest to stick with the same rom that I am using. It is available at https://github.com/loktar00/chip8 and called &quot;IBM Logo.ch8&quot;. It should be placed in the src folder alongside the .rs files. Now we can start the test.rs file.</p>
<pre><code class="language-rust">// tests.rs

use super::*;

#[test]
fn test_ibm_logo_rom(){
    let mut chip = Chip8::new(include_bytes!(&quot;IBM Logo.ch8&quot;));
    for _ in 0..700{
        chip.step();
    }
}</code></pre>
<p>As before, a quick explanation will be given for each line.</p>
<p><code>use super::*;</code> gives the tests access to the objects in lib.rs.</p>
<p><code>#[test]</code> tells cargo that the next function is a test function.</p>
<pre><code class="language-rust">let mut chip = Chip8::new(include_bytes!(&quot;IBM Logo.ch8&quot;));</code></pre>
<p>This will initialize the emulator and give it the ibm logo rom.</p>
<pre><code class="language-rust">for _ in 0..700{
    chip.step();
}</code></pre>
<p>This will run the test rom for 700 instructions. This is overkill, but for the test roms it will be better to run for more steps than needed than to run too few steps.</p>
<p>Now if you run the tests using <code>cargo test</code> it will successfully compile but the test will fail. It should say &quot;not yet implemented&quot; because the tests runs the new function that only contains <code>todo!()</code>. Next we will focus on passing the test.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-the-first-test"><a class="header" href="#passing-the-first-test">Passing the First Test</a></h1>
<p>Only two small changes are needed pass the first test. The new function needs to create an instance of the Chip8 object and return it, and the step function can be emptied. Unfortunately, while it will pass the test, it doesn't accomplish anything meaningful. Instead, we will first change the new function so that it will also store the program. To accomplish this we will also need to modify the Chip8 struct.</p>
<p>The Chip-8 system loads programs by putting them into ram at a particular location. Fortunatly, the Chip-8 only has one type of ram. This is unlike many other systems, and comes with the advantage that program data can be treated as exactly like any other data. In many other systems, like the Gameboy, the program data isn't writeable so special care needs to be taken when emulating it.</p>
<p>The actual memory for the Chip-8 system is 12 bit addressable, meaning there are 4096 bytes of memory. The program needs to start at address 512. For simplicity, hex values will be used frequently when dealing with memory. This means that there are 0xFFF addresses and programs start at address 0x200.</p>
<p>In all, this means that the following changes need to be made.</p>
<pre><code class="language-rust">// lib.rs

pub struct Chip8{
    ram: [u8; 0xFFF],
    pc: usize
}

impl Chip8{
    pub fn new(program: &amp;[u8])-&gt;Self{
        let mut ram = [0; 0xFFF];

        ram[0x200..0x200+program.len()].copy_from_slice(program);

        Self{
            ram,
            pc: 0x200
        }
    }
    ...
}</code></pre>
<p>Adding the line <code>ram: [u8; 0xFFF],</code> to the struct makes it so 0xFFF bytes of memory are available.
After that the <code>pc: usize</code> holds the program counter, where the next instruction in located in memory.</p>
<p>Adding <code>let mut ram = [0; 0xFFF];</code> initalized those bytes to zero.</p>
<p>The complicated looking line <code>ram[0x200..=0x200+program.len()].copy_from_slice(program);</code> copies the program starting at 0x200;</p>
<p>Finally, the last part creates the Chip8 instance with the ram and with a program counter set to the beginning of the program.</p>
<p>We also need to modify the step function. The program is made up of 16 bit values called opcodes that tell the emulator what to do.</p>
<pre><code class="language-rust">impl Chip8{
    ...
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            _ =&gt; todo!(&quot;Opcode 0x{opcode:04X}&quot;)
        }
    }
}</code></pre>
<p>The fetch method will get a 16 bit value from memory at the program counter, then increase the program counter by 2.</p>
<pre><code class="language-rust">impl Chip8{
    ...
    fn fetch(&amp;mut self)-&gt;u16{
        let mut opcode = 0;
        opcode |= (self.ram[self.pc] as u16) &lt;&lt; 8;
        opcode |= self.ram[self.pc+1] as u16;
        self.pc = (self.pc + 2) % 0x1000;
        opcode
    }
}</code></pre>
<p>Now if we run the test, it will still fail but it will say what opcode needs to be implemented for it to not fail again. Now we just need to implement the opcodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-instructions-for-the-first-test"><a class="header" href="#basic-instructions-for-the-first-test">Basic Instructions for the First Test</a></h1>
<p>Now that we have the emulator telling us what instructions we need to implement, we can just repeatedly implement whatever instruction that causes the test to fail.</p>
<p>The first instruction that is needed is 0x00E0, however this instruction clears the screen. The screen is slightly complicated, so we will handle that later. For now, we will skip it like this.</p>
<pre><code class="language-rust">impl Chip8{
    ...
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            0x00E0 =&gt; (),
            ...
        }
    }
}</code></pre>
<p>This will mostly be how implementing instructions will go. Rust's match statement will run the first section the matches the pattern. Putting something like 0x00E0 will only run if opcode matches that exactly. An underscore matches everything so it needs to be last. We will also make use of ranges, for example 0x0000..=0x0FFF will match any value between 0x0000 and 0x0FFF inclusive. We can also add an extra condition, but that can be demonstrated later.</p>
<p>The next instruction is 0xA22A. Instructions that start with A will set the index register, so 0xA22A sets it to 0x22A. The address register hasn't been added yet but it is simple. We can add another helper function that gets the value it should be set to. Then we just need to match on the range from 0xA000 to 0xAFFF. All these changes should look something like this.</p>
<pre><code class="language-rust">pub struct Chip8{
    ...
    index: u16
}

impl Chip8{
    pub fn new(program: &amp;[u8])-&gt;Self{
        Self{
            ...
            index: 0,
        }
    }
    pub fn step(&amp;mut self){
        match opcode{
            0xA000..=0xAFFF =&gt; self.index = Self::get_nnn(opcode),
            ...
        }
    }
    fn get_nnn(opcode: u16)-&gt;u16{
        opcode &amp; 0x0FFF
    }
}</code></pre>
<p>The function get_nnn will be part of a set of functions that help with certain instructions. Different instructions will need different parts of the opcode so these will help keep the code cleaner. They will be implented as needed.</p>
<p>Next is 0x600C. This one splits the opcode like 0x6XNN and sets the Xth register to NN. There are 16 8 bit registers in the Chip-8 that we need to add in for this instruction. We also need to add in two more helper functions for this.</p>
<pre><code class="language-rust">pub struct Chip8{
    ...
    registers: [u8; 16],
}

impl Chip8{
    pub fn new(program: &amp;[u8])-&gt;Self{
        Self{
            ...
            registers: [0; 16],
        }
    }
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            0x6000..=0x6FFF =&gt; self.registers[Self::get_x(opcode)] = Self::get_nn(opcode),
            ...
        }
    }
    fn get_nn(opcode: u16)-&gt;u8{
        (opcode &amp; 0x00FF) as u8
    }
    fn get_x(opcode: u16)-&gt;usize{
        ((opcode &amp; 0x0F00) &gt;&gt; 8) as usize
    }
}</code></pre>
<p>Next we have 0xD01F. This is another screen related instructions so we can skip the 0xD000..=0xDFFF range like we did with 0x00E0.</p>
<pre><code class="language-rust">impl Chip8{
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            0xD000..=0xDFFF =&gt; (),
            ...
        }
    }
}</code></pre>
<p>After that comes 0x7009. These are similar the the 0x6--- instructions except they add to the register rather than just setting it. We want to prevent the emulator from crashing if it overflows so we need to use wrapping_add.</p>
<pre><code class="language-rust">impl Chip8{
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            0x7000..=0x7FFF =&gt; self.registers[Self::get_x(opcode)] = self.registers[Self::get_x(opcode)].wrapping_add(Self::get_nn(opcode)),
            ...
        }
    }
}</code></pre>
<p>Lastly we have 0x1228. The 0x1NNN instructions set the program counter, pc, to NNN.</p>
<pre><code class="language-rust">impl Chip8{
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            0x1000..=0x1FFF =&gt; self.pc = Self::get_nnn(opcode) as usize,
            ...
        }
    }
}</code></pre>
<p>Now if we run the test it actually passes, however since we didn't add the graphical instructions we can't see the results, so that will be the next step.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphical-instructions-for-the-first-test"><a class="header" href="#graphical-instructions-for-the-first-test">Graphical Instructions for the First Test</a></h1>
<p>We only have two instructions to implement, 0x00E0 and the 0xD--- range, but before we do that we need to add a display. We can simply use a 2d array of booleans to represent the screen. The screen is 64x32 and starts with all pixels off.</p>
<pre><code class="language-rust">pub struct Chip8{
    ...
    screen: [[bool; 32]; 64],
}

impl Chip8{
    pub fn new(program: &amp;[u8])-&gt;Self{
        Self{
            ...
            screen: [[false; 32]; 64],
        }
    }
}</code></pre>
<p>Now we can implement the 0x00E0 instruction really easily by just reseting the screen variable.</p>
<pre><code class="language-rust">impl Chip8{
    ...
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            0x00E0 =&gt; self.screen = [[false; 32]; 64],
            ...
        }
    }
}</code></pre>
<p>Next we want to implement the 0xD--- block. For this we need two more helper functions: get_y and get_n.</p>
<pre><code class="language-rust">impl Chip8{
    ...
    fn get_y(opcode: u16)-&gt;usize{
        ((opcode &amp; 0x00F0) &gt;&gt; 4) as usize
    }
    fn get_n(opcode: u16)-&gt;u8{
        (opcode &amp; 0x000F) as u8
    }
}</code></pre>
<p>Then we want to create and call a function to handle drawing that we pass x, y, and n.</p>
<pre><code class="language-rust">impl Chip8{
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            0xD000..=0xDFFF =&gt; self.draw(Self::get_x(opcode), Self::get_y(opcode), Self::get_n(opcode)),
            ...
        }
    }
    fn draw(&amp;mut self, rx: usize, ry: usize, n: u8){
        
    }
}</code></pre>
<p>As for the actual drawing, it works like this: the index register points to a sprite. The spite is 8 pixels wide and n pixels tall and we need to draw it starting with the top left at (x,y) where x is the value in the rx register and y is the value in the ry register. Each pixel is represented by one bit in the spite and each row is one byte. If the bit is on, we toggle that pixel, otherwise we don't do anything. If a pixel turns off, we need to set the last 8 bit register to 1, otherwise we set it to 0. We also need to keep in mind that if x is bigger than the width or y is bigger than the height we wrap around, but only for the start posision. If the sprite starts drawing and doesn't fit on the screen where it's at it will just stop. To acheve this last point, we just need to do <code>let x = self.registers[rx]%64;</code> and <code>let y = self.registers[ry]%32;</code> and only at the very begining. All together the drawing function can look something like this.</p>
<pre><code class="language-rust">impl Chip8{
    fn draw(&amp;mut self, rx: usize, ry: usize, n: u8){
        // Set to false to start with, set to true if any pixels are toggled to off
        self.registers[15] = 0;

        // Get inital location on the screen
        let x = self.registers[rx]%64;
        let y = self.registers[ry]%32;

        // for each row in the sprite
        for dy in 0..n{

            // get y coordinate for that row
            let py = (y + dy) as usize;

            // Stop drawing if its off the screen
            if py &gt;= 32{
                return;
            }

            // Get the byte for that row
            let byte = self.ram[self.index as usize + dy as usize];

            // For each column in the sprite
            for dx in 0..8{

                // get x coordinate for that column
                let px = (x + dx) as usize;

                // stop drawing row if its off the screen
                if px &gt;= 64{
                    break;
                }

                // get bit for the row/column in the sprite
                let bit = byte &amp; (0x80 &gt;&gt; dx) != 0;

                // If it should toggle the pixel on the screen
                if bit{

                    // If the pixel is alread on, toggle it to off and set the last register to 1
                    // Otherwise just turn the pixel on on the screen
                    if self.screen[px][py]{
                        self.screen[px][py] = false;
                        self.registers[15] = 1;
                    } else {
                        self.screen[px][py] = true;
                    }
                }
            }
        }
    }
}</code></pre>
<p>At this point, the IBM logo should be successfully drawn. To see it, we can modify the test function to print display the screen and purposefully fail the test.</p>
<pre><code class="language-rust">// tests.rs

use super::*;

#[test]
fn test_ibm_logo_rom(){
    let mut chip = Chip8::new(include_bytes!(&quot;IBM Logo.ch8&quot;));
    for _ in 0..700{
        chip.step();
    }
    for y in 0..32{
        for x in 0..64{
            if chip.screen[x][y]{
                print!(&quot;█&quot;)
            } else {
                print!(&quot; &quot;)
            }
        }
        println!()
    }
    panic!();
}</code></pre>
<p>The expected result is shown below. The frame was added to show the space around the logo aswell.</p>
<pre><code>------------------------------------------------------------------
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|            ████████ █████████   █████         █████            |
|                                                                |
|            ████████ ███████████ ██████       ██████            |
|                                                                |
|              ████     ███   ███   █████     █████              |
|                                                                |
|              ████     ███████     ███████ ███████              |
|                                                                |
|              ████     ███████     ███ ███████ ███              |
|                                                                |
|              ████     ███   ███   ███  █████  ███              |
|                                                                |
|            ████████ ███████████ █████   ███   █████            |
|                                                                |
|            ████████ █████████   █████    █    █████            |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
|                                                                |
------------------------------------------------------------------
</code></pre>
<p>Next we just need to test if the output matches the expected output. We can modify the test function again to do this.</p>
<pre><code class="language-rust">use super::*;

#[test]
fn test_ibm_logo_rom(){
    const TARGET: [&amp;str; 32] = [
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;            ████████ █████████   █████         █████            &quot;,
        &quot;                                                                &quot;,
        &quot;            ████████ ███████████ ██████       ██████            &quot;,
        &quot;                                                                &quot;,
        &quot;              ████     ███   ███   █████     █████              &quot;,
        &quot;                                                                &quot;,
        &quot;              ████     ███████     ███████ ███████              &quot;,
        &quot;                                                                &quot;,
        &quot;              ████     ███████     ███ ███████ ███              &quot;,
        &quot;                                                                &quot;,
        &quot;              ████     ███   ███   ███  █████  ███              &quot;,
        &quot;                                                                &quot;,
        &quot;            ████████ ███████████ █████   ███   █████            &quot;,
        &quot;                                                                &quot;,
        &quot;            ████████ █████████   █████    █    █████            &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
    ];

    let mut chip = Chip8::new(include_bytes!(&quot;IBM Logo.ch8&quot;));
    for _ in 0..700{
        chip.step();
    }
    for y in 0..32{
        for x in 0..64{
            if chip.screen[x][y]{
                print!(&quot;█&quot;)
            } else {
                print!(&quot; &quot;)
            }
        }
        println!()
    }

    for y in 0..32{
        for x in 0..64{
            if chip.screen[x][y]{
                assert_eq!(TARGET[y].chars().nth(x).unwrap(), '█');
            } else {
                assert_eq!(TARGET[y].chars().nth(x).unwrap(), ' ');
            }
        }
    }
}</code></pre>
<p>This final version of this test will be how the rest of the tests are implemented. As long as we know the expected output, this will check that the actual output matches and if not, it should display the actual output to the screen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkpoint-1"><a class="header" href="#checkpoint-1">Checkpoint 1</a></h1>
<p>At this point, it is useful to show the current version of both the lib.rs file and the test.rs file so if anyone is having issues following the text, they can hopefully see how to procede based on the final code.</p>
<pre><code class="language-rust">// lib.rs
#[cfg(test)]
mod tests;

pub struct Chip8{
    ram: [u8; 0xFFF],
    pc: usize,
    index: u16,
    registers: [u8; 16],
    screen: [[bool; 32]; 64],
}

impl Chip8{
    pub fn new(program: &amp;[u8])-&gt;Self{
        let mut ram = [0; 0xFFF];

        ram[0x200..0x200+program.len()].copy_from_slice(program);

        Self{
            ram,
            pc: 0x200,
            index: 0,
            registers: [0; 16],
            screen: [[false; 32]; 64],
        }
    }
    pub fn step(&amp;mut self){
        let opcode = self.fetch();
        match opcode{
            0x00E0 =&gt; self.screen = [[false; 32]; 64],
            0x1000..=0x1FFF =&gt; self.pc = Self::get_nnn(opcode) as usize,
            0x6000..=0x6FFF =&gt; self.registers[Self::get_x(opcode)] = Self::get_nn(opcode),
            0x7000..=0x7FFF =&gt; self.registers[Self::get_x(opcode)] = self.registers[Self::get_x(opcode)].wrapping_add(Self::get_nn(opcode)),
            0xA000..=0xAFFF =&gt; self.index = Self::get_nnn(opcode),
            0xD000..=0xDFFF =&gt; self.draw(Self::get_x(opcode), Self::get_y(opcode), Self::get_n(opcode)),
            _ =&gt; todo!(&quot;Opcode 0x{opcode:04X}&quot;)
        }
    }
    fn fetch(&amp;mut self)-&gt;u16{
        let mut opcode = 0;
        opcode |= (self.ram[self.pc] as u16) &lt;&lt; 8;
        opcode |= self.ram[self.pc+1] as u16;
        self.pc = (self.pc + 2) % 0x1000;
        opcode
    }

    fn draw(&amp;mut self, rx: usize, ry: usize, n: u8){
        // Set to false to start with, set to true if any pixels are toggled to off
        self.registers[15] = 0;

        // Get inital location on the screen
        let x = self.registers[rx]%64;
        let y = self.registers[ry]%32;

        // for each row in the sprite
        for dy in 0..n{

            // get y coordinate for that row
            let py = (y + dy) as usize;

            // Stop drawing if its off the screen
            if py &gt;= 32{
                return;
            }

            // Get the byte for that row
            let byte = self.ram[self.index as usize + dy as usize];

            // For each column in the sprite
            for dx in 0..8{

                // get x coordinate for that column
                let px = (x + dx) as usize;

                // stop drawing row if its off the screen
                if px &gt;= 64{
                    break;
                }

                // get bit for the row/column in the sprite
                let bit = byte &amp; (0x80 &gt;&gt; dx) != 0;

                // If it should toggle the pixel on the screen
                if bit{

                    // If the pixel is alread on, toggle it to off and set the last register to 1
                    // Otherwise just turn the pixel on on the screen
                    if self.screen[px][py]{
                        self.screen[px][py] = false;
                        self.registers[15] = 1;
                    } else {
                        self.screen[px][py] = true;
                    }
                }
            }
        }
    }


    fn get_nnn(opcode: u16)-&gt;u16{
        opcode &amp; 0x0FFF
    }
    fn get_nn(opcode: u16)-&gt;u8{
        (opcode &amp; 0x00FF) as u8
    }
    fn get_n(opcode: u16)-&gt;u8{
        (opcode &amp; 0x000F) as u8
    }
    fn get_x(opcode: u16)-&gt;usize{
        ((opcode &amp; 0x0F00) &gt;&gt; 8) as usize
    }
    fn get_y(opcode: u16)-&gt;usize{
        ((opcode &amp; 0x00F0) &gt;&gt; 4) as usize
    }

}</code></pre>
<pre><code class="language-rust">// test.rs
use super::*;

#[test]
fn test_ibm_logo_rom(){
    const TARGET: [&amp;str; 32] = [
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;            ████████ █████████   █████         █████            &quot;,
        &quot;                                                                &quot;,
        &quot;            ████████ ███████████ ██████       ██████            &quot;,
        &quot;                                                                &quot;,
        &quot;              ████     ███   ███   █████     █████              &quot;,
        &quot;                                                                &quot;,
        &quot;              ████     ███████     ███████ ███████              &quot;,
        &quot;                                                                &quot;,
        &quot;              ████     ███████     ███ ███████ ███              &quot;,
        &quot;                                                                &quot;,
        &quot;              ████     ███   ███   ███  █████  ███              &quot;,
        &quot;                                                                &quot;,
        &quot;            ████████ ███████████ █████   ███   █████            &quot;,
        &quot;                                                                &quot;,
        &quot;            ████████ █████████   █████    █    █████            &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
        &quot;                                                                &quot;,
    ];

    let mut chip = Chip8::new(include_bytes!(&quot;IBM Logo.ch8&quot;));
    for _ in 0..700{
        chip.step();
    }
    for y in 0..32{
        for x in 0..64{
            if chip.screen[x][y]{
                print!(&quot;█&quot;)
            } else {
                print!(&quot; &quot;)
            }
        }
        println!()
    }

    for y in 0..32{
        for x in 0..64{
            if chip.screen[x][y]{
                assert_eq!(TARGET[y].chars().nth(x).unwrap(), '█');
            } else {
                assert_eq!(TARGET[y].chars().nth(x).unwrap(), ' ');
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">Todo</a></h1>
<p>Right now this is an incomplete guide. The next steps are to add the rest of the instructions, add input support, add audio, add more tests, and finally add a proper display, like sdl.</p>
<p>I do intend to complete this guide, but in the mean time feel free to try to continue on your own. Finding test roms for chip8 is pretty easy but here are some good links:</p>
<p><a href="https://github.com/corax89/chip8-test-rom/">https://github.com/corax89/chip8-test-rom/</a></p>
<p><a href="https://github.com/Timendus/chip8-test-suite">https://github.com/Timendus/chip8-test-suite</a></p>
<p>Keep in mind that some tests might need more cycles to complete.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<hr />
<p><a href="https://tobiasvl.github.io/blog/write-a-chip-8-emulator/">https://tobiasvl.github.io/blog/write-a-chip-8-emulator/</a></p>
<p>This site was useful for showing how each instruction should be implemented. It is a bit less hand-holdy so it's a good reference for anyone who wants to try this on their own.</p>
<hr />
<p><a href="https://en.wikipedia.org/wiki/CHIP-8">https://en.wikipedia.org/wiki/CHIP-8</a></p>
<p>Wikipedia has some good information as well as lots of further reading.</p>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
